import { Component, HostListener, OnInit } from '@angular/core';
import { timer } from 'rxjs';

/**
 * Typings for the Player data.
 * Mostly has to do with vlaues to calculate their positioning
 * The position, velocity, acceleration, and force are all vector values. ([+-X, +-Y])
 */
type Player = {
  position: [number, number],
  velocity: [number, number],
  acceleration: [number, number],
  force: [number, number],
  mass: number
  width: number
}
/**
 * Typings for the game settings data.
 * Just some numeric values to adjust the game's physics engine.
 */
type GameSettings = {
  frictionCoefficient: number,
  rinkDimensions: [number, number],
  movementCoefficient: number,
  maxVelocity: number,
  bounceCoefficient: number
}
export type { Player, GameSettings }

/**
 * A class representing the entire game's state.
 * This will be the stateful comopenent that controls how all the other stateless componenets render.
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {
  // The frame counter that the game is currently on. (60 / 1 second)
  frame: number;
  // The timestamp of the latest frame.
  timestamp: number;
  // The RXJS timer observable to keep in-game time.
  gameTimer = timer(0, 1000/60);
  // Some values to adjust the game engine.
  gameSettings:GameSettings = {
    frictionCoefficient: 0.004,
    rinkDimensions: [1250, 800],
    movementCoefficient: 0.01,
    maxVelocity: 2,
    bounceCoefficient: 0.6
  };
  // An array of the players.
  // Just loading one for now to test with.
  players: Player[] = [
    {
      position: [500, 200],
      velocity: [0, 0],
      acceleration: [0, 0],
      force: [0, 0],
      mass: 20,
      width: 70
    },
    {
      position: [500, 400],
      velocity: [0, 0],
      acceleration: [0, 0],
      force: [0, 0],
      mass: 20,
      width: 70
    }
  ];
  // The index of the player that is currently being controlled.
  selectedPlayer = 0;
  // A keymap to keep track of what buttons the player has pressed
  keymap = {
    'w': false,
    'a': false,
    's': false,
    'd': false
  }

  constructor() {}

  /**
   * Starting the game engine's timer.
   */
  ngOnInit() {
    this.frame = 0,
    this.timestamp = Date.now();
    this.gameTimer.subscribe(val => this.updateTick(val));
  }

  /**
   * Event listener on the body for when a key is pressed down.
   * Updates keymap and applies a force to the player
   */
  @HostListener('document:keydown', ['$event'])
  onKeyDown(ev: KeyboardEvent) {
    // Updating keymap.
    if(ev.key === 'w') this.keymap.w = true;
    if(ev.key === 'a') this.keymap.a = true;
    if(ev.key === 's') this.keymap.s = true;
    if(ev.key === 'd') this.keymap.d = true;
  }
  /**
   * Event listener on the body for when a key has been released.
   * Updates keymap and removes any forces being applied to the player
   */
  @HostListener('document:keyup', ['$event'])
  onKeyUp(ev: KeyboardEvent) {
    if(ev.key === 'w') this.keymap.w = false;
    if(ev.key === 'a') this.keymap.a = false;
    if(ev.key === 's') this.keymap.s = false;
    if(ev.key === 'd') this.keymap.d = false;
  }
  
  /**
   * A function to update the game state for one tick (1/60 of a second).
   * This is responsible for the game engine's physics calculations.
   * @param frame The frame that's being added. This is generated by RXJS's timer.
   */
  private updateTick(frame:number) {
    // Keeping track of the frames.
    this.frame = frame;
    this.timestamp = Date.now();
    
    // Looping through each player to calculate their new position.
    this.players = this.players.map((player, i) => {
      // First we'll calculate what forces are being applied to the player
      if(i === this.selectedPlayer) {
        player.force = this.getForce();
      }

      // Then velocity of the object from the forces being applied to the player.
      player.velocity = this.calcVelocity(player.velocity, player.force, player.mass);
      return player;
    });

    // Then we'll check if the player is going to collide with anything based on their current movement.
    // If so, then this will return a player object with an elastic collision performed.
    this.players = this.checkCollisions();

    this.players = this.players.map((player, i) => {
      // Updating the player's position.
      player.position = this.calcPosition(player.position, player.velocity);
      return player
    })
  }

  /**
   * A function to look at what keys are being pressed and calculate what force vector. should be applied.
   * @returns A force vector that always equals the movementCoefficient.
   */
  private getForce(): [number, number] {
    // Calculating what force is being applied.
    let forceX = 0;
    let forceY = 0;

    if(this.keymap.w === true) forceY -= this.gameSettings.movementCoefficient;
    if(this.keymap.a === true) forceX -= this.gameSettings.movementCoefficient;
    if(this.keymap.s === true) forceY += this.gameSettings.movementCoefficient;
    if(this.keymap.d === true) forceX += this.gameSettings.movementCoefficient;

    // If the player is going in a diagonal direction, we'll have to triangulate the force. 
    if(forceX !== 0 && forceY !== 0) {
      forceX *= Math.cos(45);
      forceY *= Math.sin(45);
    }

    // Updating the controlled player
    return [forceX, forceY];
  }

  /**
   * A function representing the physics formula D = V * T. Adds distance based on current player's velocity.
   * @param velocity The player's current velocity vector.
   * @returns A distance vector based on a pixel coordinate plane.
   */
  private calcPosition(currentPosition:[number, number], velocity: [number, number]): [number, number] {
    return [
      currentPosition[0] + (velocity[0] * (1000/60)),
      currentPosition[1] + (velocity[1]* (1000/60))
    ];
  }

  /**
   * A function representing the physics formula V = (F * t) / m. Calculates the new velocity vector based on the acceleration.
   * @param acceleration The player's current acceleration vector.
   * @returns A velocity vector.
   */
  private calcVelocity(velocity:[number, number], force: [number, number], mass: number): [number, number] {
    // Guard clause to prevent going above max velocity
    if(Math.pow(Math.pow(velocity[0], 2) + Math.pow(velocity[1], 2), 0.5) > this.gameSettings.maxVelocity) return velocity;

    // Adding velocity.
    velocity[0] += ((force[0] * (1000/60))/mass);
    velocity[1] += ((force[1] * (1000/60))/mass);

    // Applying friction based on the current velocity.
    velocity[0] -= (velocity[0] * this.gameSettings.frictionCoefficient);
    velocity[1] -= (velocity[1] * this.gameSettings.frictionCoefficient);

    return velocity;
  }

  /**
   * A function that will check for collisions based on the current player's movement.
   * If a player does collide with an object or the wall, will perform an inelastic collision calculation (right now it's just negating for testing).
   * @param currentPlayer The player that is being check for collisions.
   * @returns The update player values.
   */
  private checkCollisions(): Player[] {
    const collisionsPerformed:[number, number][] = [];

    const newPlayers = [...this.players];

    newPlayers.forEach((currentPlayer, i) => {
      // Calculating the potential position if no collision occured.
      const potentialPosition = this.calcPosition(currentPlayer.position, currentPlayer.velocity);

      // Checking for left and right wall collisions.
      if (
        potentialPosition[0] < currentPlayer.width/2 ||
        potentialPosition[0] > this.gameSettings.rinkDimensions[0] - currentPlayer.width/2 ||
        potentialPosition[1] < 0 ||
        potentialPosition[1] > this.gameSettings.rinkDimensions[1]
      ) {
        currentPlayer.velocity = this.calcCollision({mass: currentPlayer.mass, velocityInitial: currentPlayer.velocity}, {mass:100, velocityInitial:[0,0]})[0];
      }

      this.players.forEach((player, j) => {
        const player1Edges = {
          top: currentPlayer.position[1] - (currentPlayer.width/2),
          bottom: currentPlayer.position[1] + (currentPlayer.width/2),
          left: currentPlayer.position[0] - (currentPlayer.width/2),
          right: currentPlayer.position[0] + (currentPlayer.width/2)
        }
        const player2Edges = {
          top: player.position[1] - (player.width/2),
          bottom: player.position[1] + (player.width/2),
          left: player.position[0] - (player.width/2),
          right: player.position[0] + (player.width/2)
        }

        if (
          player1Edges.left < player2Edges.right &&
          player1Edges.right > player2Edges.left &&
          player1Edges.top < player2Edges.bottom &&
          player1Edges.bottom > player2Edges.top
        ) {
          const collidedVelocities = this.calcCollision(
            {mass: currentPlayer.mass, velocityInitial: currentPlayer.velocity},
            {mass: player.mass, velocityInitial: player.velocity}
          );

          newPlayers[i].velocity = collidedVelocities[0];
          newPlayers[j].velocity = collidedVelocities[1];

          collisionsPerformed.push([i, j]);
        }
      })
    });

    return newPlayers;
  }

  private calcCollision(object1: {
    mass: number,
    velocityInitial:[number, number]
  }, object2: {
    mass: number,
    velocityInitial: [number, number]
  }): [[number, number], [number, number]] {
    const finalVelocity1X = (((object1.mass - object2.mass) * object1.velocityInitial[0]) + (2 * object2.mass * object2.velocityInitial[0])) / (object1.mass + object2.mass);
    const finalVelocity1Y = (((object1.mass - object2.mass) * object1.velocityInitial[1]) + (2 * object2.mass * object2.velocityInitial[1])) / (object1.mass + object2.mass);

    const finalVelocity2X = (((object2.mass - object1.mass) * object2.velocityInitial[0]) + (2 * object1.mass * object1.velocityInitial[0])) / (object1.mass + object2.mass);
    const finalVelocity2Y = (((object2.mass - object1.mass) * object2.velocityInitial[1]) + (2 * object1.mass * object1.velocityInitial[1])) / (object1.mass + object2.mass);

    return [[finalVelocity1X, finalVelocity1Y], [finalVelocity2X, finalVelocity2Y]];
  }
}
